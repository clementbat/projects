<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <title>Treemap demo</title>

    <style>
        #app {
            font-family: 'Avenir', Helvetica, Arial, sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-align: center;
            color: #2c3e50;
            margin-top: 30px;
        }

        .rectangle:hover {
            opacity: 1;
            cursor: pointer;
        }

        .rectangle {
            opacity: 0.4;
        }

        .hello {
            display: flex;
            justify-content: space-between;
            width: 90%;
            margin: auto;
        }

        input {
            margin-top: 5px;
            width: 40px;
            font-size: 14px;
            text-align: center;
            border: 1px solid #E0E0E0;
            border-radius: 3px;
        }

        button {
            border: 1px solid #4DB6AC;
            color: #4DB6AC;
            font-size: 14px;
            cursor: pointer;
            border-radius: 3px;
        }

        button.reload {
            margin-top: 30px;
            width: 78px;
            height: 30px;
        }

        button:hover {
            background-color: #4DB6AC;
            color: white;
        }

        button.delete-data-point {
            width: 30px;
            height: 21px;
            color: #FF5722;
            border-color: #FF5722;
        }

        button:hover.delete-data-point {
            color: white;
            background-color: #FF5722;
        }

        button.add-data-point {
            width: 30px;
            height: 21px;
        }

    </style>

</head>
<body>

<script src="https://unpkg.com/vue"></script>

<div id="app">
    <div class="hello">
        <div>
            Change the data here:<br><br>
            <div v-for="(item, index) in data">
                <input
                        v-model="data[index]"
                        v-on:change="refreshTreemap(data)">
                <button class="delete-data-point" v-on:click="data.splice(index, 1); refreshTreemap(data)">X</button>
            </div>
            <br>
            <div>
                <input
                        v-model="inputNewData"
                        v-on:keyup.enter="addNewData"
                        placeholder="Add"
                >
                <button class="add-data-point" v-on:click="addNewData">+</button>
            </div>
            <button class="reload" v-on:click="refreshTreemap(data)">Refresh</button>
            <div v-if="text">
                <br><br>Current data: {{text}}
            </div>
            <div v-if="errorText">
                <br><br>
                {{errorText}}
            </div>
        </div>
        <div style="width: 100%;">
            <svg :width="width" :height="height">
                <g
                    v-for="rectangle in rectangles"
                    v-on:click="clicked(getLabel(rectangle))"
                    v-on:mouseenter="moused(getLabel(rectangle))"
                    v-on:mouseleave="unmoused"
                    class="rectangle"
                    :fill="getColor(rectangle)">
                    <rect
                        :x=rectangle[0]
                        :y=rectangle[1]
                        :width=rectangle[2]
                        :height=rectangle[3]
                        style="stroke-width:1;stroke:white"/>
                    <text
                        :x="rectangle[0] + rectangle[2] / 2"
                        :y="rectangle[1] + rectangle[3] / 2"
                        fill="white">
                        {{getLabel(rectangle)}}
                    </text>
                </g>
                Sorry, your browser does not support inline SVG.
            </svg>
        </div>
    </div>
</div>

<script>
    new Vue({
        el: '#app',
        data () {
            return {
                dataset: [],
                text: '',
                inputNewData: '',
                data: [
                    10,
                    7,
                    4,
                    1,
                    5,
                    9,
                ],
                colors: [],
                errorText: '',
                height: 600,
                width: 900,
                Rectangle: {
                    data: [],
                    xBeginning: 0,
                    yBeginning: 0,
                    totalWidth: 900,
                    totalHeight: 600,
                },
            }
        },
        mounted () {
            let i = 0
            while (i < 100) {
                const greyShade = Math.round(Math.random() * 150)

                function componentToHex (c) {
                    const hex = c.toString()
                    return hex.length === 1 ? '0' + hex : hex
                }

                function rgbToHex (r, g, b) {
                    return '#' + componentToHex(r) + componentToHex(g) + componentToHex(b)
                }

                this.colors.push(rgbToHex(greyShade, greyShade, greyShade))

                i += 1
            }
            this.loadTreemap(this.data)
        },
        computed: {
            rectangles() {
                return this.dataset
            }
        },
        methods: {
            getX(rectangle) {
                return rectangle[0]
            },
            getY(rectangle) {
                return rectangle[1]
            },
            getWidth(rectangle) {
                return rectangle[2]
            },
            getHeight(rectangle) {
                return rectangle[3]
            },
            getLabel(rectangle) {
                return rectangle[4]
            },
            getColor(rectangle) {
                return rectangle[5]
            },
            addNewData () {
                if (this.inputNewData && !isNaN(this.inputNewData)) {
                    this.data.push(this.inputNewData)
                    this.refreshTreemap(this.data)
                }
                this.inputNewData = ''
            },
            refreshTreemap (data) {
                this.errorText = ''
                data.forEach((dataPoint) => {
                    if (isNaN(dataPoint) || dataPoint < 0) {
                        this.errorText = 'Please enter positive data points'
                    }
                })
                if (!this.errorText) {
                    this.loadTreemap(JSON.parse('[' + data + ']'))
                }
            },
            clicked (id) {
                alert(`Data clicked: ${id}`)
            },
            moused (text) {
                this.text = text
            },
            unmoused () {
                this.text = ''
            },
            loadTreemap (data) {
                const dataset = data
                    .slice(0)
                    .map(el => (el * this.Rectangle.totalHeight * this.Rectangle.totalWidth) / data.reduce(this.sum))

                this.squarify(dataset, [], this.getMinWidth().width)

                this.dataset = this.Rectangle.data
            },
            squarify (children, row, width) {

                if (children.length === 1) {
                    this.layoutLastRow(row, children, width)
                    return
                }

                const rowWithChild = [...row, children[0]]

                if (row.length === 0 || this.worst(row, width) >= this.worst(rowWithChild, width)) {
                    children.shift()
                    this.squarify(children, rowWithChild, width)
                } else {
                    this.layoutRow(row, width)
                    this.squarify(children, [], this.getMinWidth().width)
                }
            },
            layoutRow (row, width, vertical = this.getMinWidth().vertical) {
                const rowHeight = row.reduce(this.sum) / width

                row.forEach((rowItem) => {
                    const rowWidth = rowItem / rowHeight
                    const xBeginning = this.Rectangle.xBeginning
                    const yBeginning = this.Rectangle.yBeginning

                    const data = []
                    if (vertical) {
                        data.push(xBeginning, yBeginning, rowHeight, rowWidth)
                        this.Rectangle.yBeginning += rowWidth
                    } else {
                        data.push(xBeginning, yBeginning, rowWidth, rowHeight)
                        this.Rectangle.xBeginning += rowWidth
                    }

                    data.push(this.data[this.Rectangle.data.length], this.colors[this.Rectangle.data.length])

                    this.Rectangle.data.push(data)
                })

                if (vertical) {
                    this.Rectangle.xBeginning += rowHeight
                    this.Rectangle.yBeginning -= width
                    this.Rectangle.totalWidth = this.Rectangle.totalWidth - rowHeight
                } else {
                    this.Rectangle.xBeginning -= width
                    this.Rectangle.yBeginning += rowHeight
                    this.Rectangle.totalHeight = this.Rectangle.totalHeight - rowHeight
                }
            },
            layoutLastRow (rows, children, width) {
                const currentWidth = this.getMinWidth()
                this.layoutRow(rows, width, currentWidth.vertical)
                this.layoutRow(children, width, currentWidth.vertical)
            },
            getMinWidth () {
                if ((this.Rectangle.totalHeight) ** 2 > (this.Rectangle.totalWidth) ** 2) {
                    return {width: this.Rectangle.totalWidth, vertical: false}
                }
                return {width: this.Rectangle.totalHeight, vertical: true}
            },
            worst (row, width) {
                const sum = row.reduce(this.sum, 0)
                const rPlus = this.arrayMax(row)
                const rMoins = this.arrayMin(row)
                return Math.max(Math.pow(width, 2) * rPlus / (Math.pow(sum, 2)), Math.pow(sum, 2) / (Math.pow(width, 2) * rMoins))
            },
            sum(acc, cur) {
                return acc += cur
            },
            arrayMin(arr) {
                return arr.slice(0).sort()[0]
            },
            arrayMax(arr) {
                return arr.slice(0).sort().pop()
            },
        },
    })

</script>
</body>
</html>